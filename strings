SELECT 
	c.country,
    -- Pull in pop_in_millions and medals_per_million 
	pop_in_millions,
    -- Add the three medal fields using one sum function
	SUM(COALESCE(bronze,0) + COALESCE(silver,0) + COALESCE(gold,0)) AS medals,
	SUM(COALESCE(bronze,0) + COALESCE(silver,0) + COALESCE(gold,0)) / CAST(cs.pop_in_millions AS float) AS medals_per_million
FROM summer_games AS s
JOIN countries AS c 
ON s.country_id = c.id
-- Add a join
JOIN country_stats AS cs 
ON s.country_id = cs.country_id
GROUP BY c.country, pop_in_millions
ORDER BY medals DESC;

--------------------------------------------------------------------------------
Identifying data types
Being able to identify data types before setting up your query can help you plan for any potential issues. There is a group of tables, or a schema, called the information_schema, which provides a wide array of information about the database itself, including the structure of tables and columns.

The columns table houses useful details about the columns, including the data type.

Note that the information_schema is not the default schema SQL looks at when querying, which means you will need to explicitly tell SQL to pull from this schema. To pull a table from a non-default schema, use the syntax schema_name.table_name.



-- Pull column_name & data_type from the columns table
SELECT 
	column_name, 
    data_type
FROM information_schema.columns
-- Filter for the table 'country_stats'
WHERE table_name = 'country_stats';

--------------------------------------------------------------------
Exercise
Exercise
Interpreting error messages
Inevitably, you will run into errors when running SQL queries. It is important to understand how to interpret these errors to correctly identify what type of error it is.

The console contains two separate queries, each which will output an error when ran. In this exercise, you will run each query, read the error message, and troubleshoot the error.

-- Run the query, then convert a data type to fix the error
SELECT AVG(CAST(pop_in_millions AS float)) AS avg_population
FROM country_stats;

/*SELECT 
	s.country_id, 
    COUNT(DISTINCT s.athlete_id) AS summer_athletes, 
    COUNT(DISTINCT w.athlete_id) AS winter_athletes
FROM summer_games AS s
JOIN winter_games_str AS w
ON s.country_id = w.country_id
GROUP BY s.country_id;*/

--------------------------------------------------------------------------------
Using date functions on strings
There are several useful functions that act specifically on date or datetime fields. For example:

DATE_TRUNC('month', date) truncates each date to the first day of the month.
DATE_PART('year', date) outputs the year, as an integer, of each date value.
In general, the arguments for both functions are ('period', field), where period is a date or time interval, such as 'minute', 'day', or 'decade'.

In this exercise, your goal is to test out these date functions on the country_stats table, specifically by outputting the decade of each year using two separate approaches. To run these functions, you will need to use CAST() function on the year field.


SELECT 
	year,
    -- Pull decade, decade_truncate, and the world's gdp
    DATE_PART(____) AS decade,
    DATE_TRUNC(____) AS decade_truncated,
    ____ AS world_gdp
FROM ____
-- Group and order by year in descending order
GROUP BY ____
ORDER BY ____;

Pulling from the country_stats table, select the decade using two methods: DATE_PART() and DATE_TRUNC.
Convert the data type of the year field to fix errors.
Sum up gdp to get world_gdp.
Group and order by year (in descending order).
----------------------------------------------------------------------
String functions
There are a number of string functions that can be used to alter strings. A description of a few of these functions are shown below:

The LOWER(fieldName) function changes the case of all characters in fieldName to lower case.
The INITCAP(fieldName) function changes the case of all characters in fieldName to proper case.
The LEFT(fieldName,N) function returns the left N characters of the string fieldName.
The SUBSTRING(fieldName from S for N) returns N characters starting from position S of the string fieldName. Note that both from S and for N are optional.

SELECT 
	country, 
    lower(country) AS country_altered
FROM countries
GROUP BY country;

-- Convert country to proper case
SELECT 
	country, 
    INITCAP(country) AS country_altered
FROM countries
GROUP BY country;


-- Output the left 3 characters of country
SELECT 
	country, 
    left(country,3) AS country_altered
FROM countries
GROUP BY country;



-- Output all characters starting with position 7
SELECT 
	country, 
    substring(country,7) AS country_altered
FROM countries
GROUP BY country;



Replacing and removing substrings
The REPLACE() function is a versatile function that allows you to replace or remove characters from a string. The syntax is as follows:

REPLACE(fieldName, 'searchFor', 'replaceWith')

Where fieldName is the field or string being updated, searchFor is the characters to be replaced, and replaceWith is the replacement substring.

In this exercise, you will look at one specific value in the countries table and change up the format by using a few REPLACE() functions.


Create the field character_swap that replaces all '&' characters with 'and' from region.
Create the field character_remove that removes all periods from region.



SELECT 
	region, 
    -- Replace all '&' characters with the string 'and'
    Replace(region,'&', 'and') AS character_swap,
    -- Remove all periods
    Replace(region,'.','') AS character_remove
FROM countries
WHERE region = 'LATIN AMER. & CARIB'
GROUP BY region;


------------------------------------------------------------------------------
Fixing incorrect groupings
One issues with having strings stored in different formats is that you may incorrectly group data. If the same value is represented in multiple ways, your report will split the values into different rows, which can lead to inaccurate conclusions.

In this exercise, you will query from the summer_games_messy table, which is a messy, smaller version of summer_games. You'll notice that the same event is stored in multiple ways. Your job is to clean the event field to show the correct number of rows.


Create a query that pulls the number of distinct athletes by event from the table summer_games_messy.
Group by the non-aggregated field.


-- Pull event and unique athletes from summer_games_messy 
SELECT Distinct
	event, 
    count(athlete_id) AS athletes
FROM summer_games_messy
-- Group by the non-aggregated field
GROUP BY event;


-----------------------------------------------------------------------------------------
Filtering out nulls
One way to deal with nulls is to simply filter them out. There are two important conditionals related to nulls:

IS NULL is true for any value that is null.
IS NOT NULL is true for any value that is not null. Note that a zero or a blank cell is not the same as a null.
These conditionals can be leveraged by several clauses, such as CASE statements, WHERE statements, and HAVING statements. In this exercise, you will learn how to filter out nulls using two separate techniques.

Feel free to reference the E:R Diagram.

Setup a query that pulls country and total golds as gold_medals for all winter games.
Group by the non-aggregated field and order by gold_medals in descending order.


-- Show total gold_medals by country
SELECT 
	c.country,
    sum(w.gold) AS gold_medals
FROM winter_games AS w
JOIN countries AS c
ON w.country_id = c.id
GROUP BY c.country
-- Order by gold_medals in descending order
ORDER BY gold_medals desc;

------------------------------------------

Fixing calculations with coalesce
Null values impact aggregations in a number of ways. One issue is related to the AVG() function. By default, the AVG() function does not take into account any null values. However, there may be times when you want to include these null values in the calculation as zeros.

To replace null values with a string or a number, use the COALESCE() function. Syntax is COALESCE(fieldName,replacement), where replacement is what should replace all null instances of fieldName.

This exercise will walk you through why null values can throw off calculations and how to troubleshoot these issues.


Build a report that shows total_events and gold_medals by athlete_id for all summer events, ordered by total_events descending then athlete_id ascending.


-- Pull events and golds by athlete_id for summer events
SELECT 
    athlete_id,
    count(event) AS total_events, 
    sum(gold) AS gold_medals
FROM summer_games
GROUP BY athlete_id
-- Order by total_events descending and athlete_id ascending
ORDER BY total_events desc;

-----------------------------------------------------------------------------

Identifying duplication
Duplication can happen for a number of reasons, often in unexpected ways. Because of this, it's important to get in the habit of validating your queries to ensure no duplication exists. To validate a query, take the following steps:

Check the total value of a metric from the original table.
Compare that with the total value of the same metric in your final report.
If the number from step 2 is larger than step 1, then duplication is likely the culprit. In this exercise, you will go through these steps to identify if duplication exists.


Setup a query that pulls total gold_medals from the winter_games table.


-- Pull total gold_medals for winter sports
SELECT sum(gold) as gold_medals
FROM winter_games;


Fixing duplication through a JOIN
In the previous exercise, you set up a query that contained duplication. This exercise will remove the duplication. One approach to removing duplication is to change the JOIN logic by adding another field to the ON statement.

The final query from last exercise is shown in the console. Your job is to fix the duplication by updating the ON statement. Note that the total gold_medals value should be 47.

Feel free to reference the E:R Diagram.


SELECT SUM(gold_medals) AS gold_medals
FROM
	(SELECT 
     	w.country_id, 
     	SUM(gold) AS gold_medals, 
     	AVG(gdp) AS avg_gdp
    FROM winter_games AS w
    JOIN country_stats AS c
    -- Update the subquery to join on a second field
    ON c.country_id = w.country_id ____
    GROUP BY w.country_id) AS subquery;
    
    --------------------------------------------------
    Report 3: Countries with high medal rates
Great work so far! It is time to use the concepts you learned in this chapter to build the next base report for your dashboard.

Details for report 3: medals vs population rate.

Column 1 should be country_code, which is an altered version of the country field.
Column 2 should be pop_in_millions, representing the population of the country (in millions).
Column 3 should be medals, representing the total number of medals.
Column 4 should be medals_per_million, which equals medals / pop_in_millions

Notice the repeated values in the results. Add a column on the newest join statement to remove this duplication, and if you run into an error when trying to join, update the query so both fields are stored as type date.

SELECT 
	c.country,
    -- Pull in pop_in_millions and medals_per_million 
	pop_in_millions,
    -- Add the three medal fields using one sum function
	SUM(COALESCE(bronze,0) + COALESCE(silver,0) + COALESCE(gold,0)) AS medals,
	SUM(COALESCE(bronze,0) + COALESCE(silver,0) + COALESCE(gold,0)) / CAST(cs.pop_in_millions AS float) AS medals_per_million
FROM summer_games AS s
JOIN countries AS c 
ON s.country_id = c.id
-- Update the newest join statement to remove duplication
JOIN country_stats AS cs 
ON s.country_id = cs.country_id
GROUP BY c.country, pop_in_millions
ORDER BY medals DESC;

----------------------------------------------------------------

SELECT 
	c.country,
    -- Pull in pop_in_millions and medals_per_million 
	pop_in_millions,
    -- Add the three medal fields using one sum function
	SUM(COALESCE(bronze,0) + COALESCE(silver,0) + COALESCE(gold,0)) AS medals,
	SUM(COALESCE(bronze,0) + COALESCE(silver,0) + COALESCE(gold,0)) / CAST(cs.pop_in_millions AS float) AS medals_per_million
FROM summer_games AS s
JOIN countries AS c 
ON s.country_id = c.id
-- Update the newest join statement to remove duplication
JOIN country_stats AS cs 
ON s.country_id = cs.country_id AND s.year = CAST(cs.year AS date)
GROUP BY c.country, pop_in_millions
ORDER BY medals DESC;

    

SELECT 
	-- Clean the country field to only show country_code
    LEFT(REPLACE(UPPER(TRIM(c.country)), '.', ''), 3) AS country_code,
    -- Pull in pop_in_millions and medals_per_million 
	pop_in_millions,
    -- Add the three medal fields using one sum function
	SUM(COALESCE(bronze,0) + COALESCE(silver,0) + COALESCE(gold,0)) AS medals,
	SUM(COALESCE(bronze,0) + COALESCE(silver,0) + COALESCE(gold,0)) / CAST(cs.pop_in_millions AS float) AS medals_per_million
FROM summer_games AS s
JOIN countries AS c 
ON s.country_id = c.id
-- Update the newest join statement to remove duplication
JOIN country_stats AS cs 
ON s.country_id = cs.country_id AND s.year = CAST(cs.year AS date)
-- Filter out null populations
WHERE cs.pop_in_millions IS NOT NULL
GROUP BY c.country, pop_in_millions
-- Keep only the top 25 medals_per_million rows
ORDER BY medals_per_million DESC
LIMIT 25;

--------------------------------------------------------------------------
Testing out window functions
Window functions reference other rows within the report. There are a variety of window-specific functions to use, but all basic aggregation functions can be used as a window function. These include:

SUM()
AVG()
MAX()
MIN()
The syntax of a window function is FUNCTION(value) OVER (PARTITION BY field ORDER BY field). Note that the PARTITION BY and ORDER BY clauses are optional. The FUNCTION should be replaced with the function of your choice.

In this exercise, you will run a few different window functions on the country_stats table.

Add the field country_avg_gdp that outputs the average gdp for each country.

partition by == range of calculation 
order by == order of rows when running calculation 

sum(value) over (partition by field order by field) 

****Total bronze medals
sum(bronze) over() as total_broze 
from summer_games

**** country bronze medals 
sum(bronze) over (partition by country_id) as total_bronze 
from summer_games 

Lag()
Lead()


Row_number()
Rank()
------------------------------------------------------------------------------------

Window function on an aggregation 

select 
team_id,
sum(points) as team_points,
sum(sum(points)) over () as league_points 
from original_table 
group by team_id 

-----------------------------------------------------------------------------

Layered Calculations 
* Aggregate an existing aggregation 
* Leverages a subquery 

Layered calculations example 
step 1: total bronze medals per country 
select country_id, sum(bronze) as bronze_medals 
from summer_games 
group by country_id 

step 2: convert to subquery and take the max 
select max(bronze_medals) 
from 
(select country_id, sum(bronze) as bronze_medals
from summer_games
group by country_id) as subquery 

-------------------------------------------------------------------------------
Types of metrics 

Volume metrics and Efficiency metrics 

** Volume metrics - scale with size 
Percent of total calculation 

select team_id, sum(points) as points 
from basketball_points 
group by team_id 





Percent of total calculation 

step 1: calculate total 

select 
team_id, 
sum(points) as points 
sum(points over () as total_points 
from basketball_points 
group by team_id 

step 2: calculate percent of total 
select 
team_id, 
sum(points) as points 
sum(points)/ sum(points) over () as perc_of_total 
from basketball_points 
group by team_id 

--------------------------------------------------------------------------
Percent of total calculation 
Perfect of points scored per player for each item: 

select player_id,
team_id,
sum(points) as points 
sum(points) / (sum(points) over (partition by team_id)) as perc_of_team
from basketball_points 
group by player_id, team_id 


------------------------------------------------------------------------------------
Efficiency metrics 
  does not scale with size 
  typically a ratio 
  

Performance index 
   compares performance to a benchmark 
   benchmark typically an average or median 
  
  
  basketball_summary table 
  
  team_id	games	points
  1		24	782
  2		20	625
  3		12	487
  
  points per game performance?
  
  step 1: points per game for each team 
  select 
  team_id, 
  points/games as team_ppg
  from basketball_summary; 
  
  step 2: points per game for entire league 
  select 
  team_id, 
  points/games as team_ppg, 
  sum(points) over() / sum(games) over() as league_ppg 
  from basketball_summary
  
  step 3: performance index 
  select 
  team_id,
  point/games as team_ppg,
  sum(points) over () / sum(games) over () as league_ppg,
  (points/games) / (sum(points) over () / sum(games) over ()) as perf_index 
  from basketball_summary 
  
  team_id	team_ppg	league_ppg	perf_index
  1		32.6		33.8		0.96
  2		31.3		33.8		0.92
  3		40.6		33.8		1.20
  
  * the results clearly state that team three scores 20% more points than the league average. 
  
  
  
  
  --------------------------------------------------------------------------------------------------------------
  
  Rolling 7 days 
  
  month-over-month comparison 
  LAG(value, offset) outputs a value from an offset number of rows previous to the current row. 
  
  LEAD(value, offset) outputs a value from an offset number of rows after the current row.  
  
  
  step 1: show revenue by month 
  select 
  Date_part('month', date) as month,
  sum(revenue) as current_rev 
  from original_table 
  Group by month; 
  
  step 2: previous month's revenue 
  select 
  date_part('month', date) as month, 
  sum(revenue) as current_rev, 
  Lag(sum(revenue)) over (order by date_part('month', date)) as prev_rev 
  from original_table 
  group by month
  
  step 3: percent change calculation 
  select 
  date_part('month', date) as month, 
  sum(revenue) as current_rev,
  lag(sum(revenue)) over (order by date_part('month', date)) as prev_rev, 
  sum(revenue) / lag(sum(revenue)) over (order by date_part('month', date))-1 as perc_change 
  from original_table 
  group by month; 
  
  month-over-month comparison 
  step 3: percent change calculation 
  
  month		current_rev		prev_rev		perc_change
  01		15000			null			null
  02		14000			12000			-.06
  03		21000			14000			.50
  
  *we can clearly see from the results that we dropped 6% revenue in February and increased 50% revenue in March 
  -----------------------------------------------------------------------------------------------------------------------
  
  
  Rolling calculations 
  only take into account 7 rows 
  
  New clause: rows between 
  
  sum(value) over (order by value Rows between n preceding and current row) 
  
  ----------------------------------------------------------------------------------------------------------------------
  
  Rolling calculations 
  
  rolling sum query 
  
  select 
  date, 
  sum(sum(revenue)) over 
  (order by date rows between 6 preceding and current row) as weekly_revenue 
  from original_table 
  group by date;
  
  date		country_id		view 
  2018-01-01	1			24313
  2018-01-01	2			3768
  2018-01-01	3			26817
  
  
  
  fixing data types --- cast()
  
  parsing strings 
  
  handling nulls - coalesce() 
  
  
  
  
  
  
  
  
  
  
  
  
   

















